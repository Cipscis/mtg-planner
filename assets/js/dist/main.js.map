{"version":3,"file":"main.js","mappings":"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","sources":["webpack://mtg-planner/./server/src/routes.ts","webpack://mtg-planner/./app/assets/js/src/api/getCard.ts","webpack://mtg-planner/./server/src/middleware/SearchError.ts","webpack://mtg-planner/./server/src/middleware/typeguards.ts","webpack://mtg-planner/./app/assets/js/src/Card.ts","webpack://mtg-planner/./app/assets/js/src/DeckCard.ts","webpack://mtg-planner/./app/assets/js/src/Decklist.ts","webpack://mtg-planner/./app/assets/js/src/main.ts","webpack://mtg-planner/./app/assets/js/src/Deck.ts","webpack://mtg-planner/./app/assets/js/src/data/decklist.ts"],"sourcesContent":["const root = '/api';\n\nconst routes = {\n\troot,\n\tgetCards: `${root}/cards`,\n} as const;\n\nexport default routes;\n","import * as Scry from 'scryfall-sdk';\nimport {\n\tSearchError,\n\tisSearchError,\n} from 'server/middleware/SearchError.js';\nimport { isScryCard } from 'server/middleware/typeguards.js';\n\nimport routes from 'server/routes.js';\n\nfunction getCards(...cardNames: string[]): Promise<Array<Scry.Card | SearchError>> {\n\treturn new Promise(async (resolve, reject) => {\n\t\tconst url = `${routes.getCards}?names=${cardNames.map(encodeURIComponent).join('|')}`;\n\n\t\tconst response = await fetch(url);\n\t\tif (response.ok) {\n\t\t\tconst json: unknown = await response.json();\n\n\t\t\tif (Array.isArray(json) && json.every((value: unknown) => isSearchError(value) || isScryCard(value))) {\n\t\t\t\tresolve(json);\n\t\t\t} else {\n\t\t\t\tconsole.error(json);\n\t\t\t\treject(new Error('Response data format unrecognised.'));\n\t\t\t}\n\t\t} else {\n\t\t\treject(new Error(`Response not ok. Status: ${response.status} ${response.statusText}`));\n\t\t}\n\t});\n}\n\nasync function getCard(cardName: string): Promise<Scry.Card | SearchError> {\n\tconst cards = await getCards(cardName);\n\n\treturn cards[0];\n}\n\nexport {\n\tgetCard,\n\tgetCards,\n};\n","import * as Scry from 'scryfall-sdk';\n\ntype SearchError = Exclude<ReturnType<typeof Scry.error>, undefined>;\n\nfunction isSearchError(data: unknown): data is SearchError {\n\tconst testData = data as SearchError;\n\n\tif (\n\t\ttestData && typeof testData === 'object' &&\n\t\ttestData.object === 'error' &&\n\t\ttypeof testData.code === 'string' &&\n\t\ttypeof testData.status === 'number' &&\n\t\ttypeof testData.details === 'string' &&\n\t\t(\n\t\t\ttypeof testData.warnings === 'undefined' || (\n\t\t\t\tArray.isArray(testData.warnings) &&\n\t\t\t\ttestData.warnings.every((element: unknown): element is string => typeof element === 'string')\n\t\t\t)\n\t\t)\n\t) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tSearchError,\n\tisSearchError,\n};\n","import * as Scry from 'scryfall-sdk';\n\nfunction isScryCard(data: unknown): data is Scry.Card {\n\tconst testData = data as Scry.Card;\n\n\tif (\n\t\ttestData && typeof testData === 'object' &&\n\t\ttestData.object === 'card'\n\t) {\n\t\t// This isn't a true test, but it's a good enough one for this purpose.\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport { isScryCard };\n","import { getCard } from './api/getCard.js';\n\n// Polyfill for TypeScript < v4.5\ntype Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;\n\ninterface ICardOptions {\n\tname: string;\n\tdata?: Awaited<ReturnType<typeof getCard>>;\n\n\tdefer?: boolean;\n}\n\nclass Card implements ICardOptions {\n\tname: string;\n\tdata?: Awaited<ReturnType<typeof getCard>>;\n\n\t#isResolved: boolean;\n\tready: Promise<this>;\n\t#resolve!: (value: this | PromiseLike<this>) => void;\n\n\tconstructor(options: string | ICardOptions) {\n\t\tif (typeof options === 'string') {\n\t\t\toptions = { name: options } as ICardOptions;\n\t\t}\n\n\t\tthis.name = options.name;\n\n\t\tthis.#isResolved = false;\n\t\tthis.ready = new Promise((resolveArg, reject) => {\n\t\t\tthis.#resolve = (value: this | PromiseLike<this>) => {\n\t\t\t\tthis.#isResolved = true;\n\t\t\t\tresolveArg(value);\n\t\t\t};\n\t\t});\n\n\t\tif (options.defer !== true) {\n\t\t\tthis.getData();\n\t\t}\n\t}\n\n\tgetData(data?: Awaited<ReturnType<typeof getCard>>) {\n\t\tif (this.#isResolved === false) {\n\t\t\tif (data) {\n\t\t\t\tthis.data = data;\n\t\t\t\tthis.#resolve(this);\n\t\t\t} else {\n\t\t\t\tgetCard(this.name).then((cardData) => {\n\t\t\t\t\tthis.data = cardData;\n\t\t\t\t\tthis.#resolve(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this.ready;\n\t}\n};\n\nexport {\n\tICardOptions,\n\n\tCard,\n};\n","import { ICardOptions, Card } from './Card.js';\nimport { Decklist } from './Decklist.js';\n\ninterface IDeckCardOptions extends ICardOptions {\n\tquantity: number;\n\n\tflags?: Set<string>;\n\tgroups?: Set<string>;\n\toverrides?: Map<string, string>;\n}\n\nclass DeckCard extends Card implements IDeckCardOptions {\n\tquantity: number;\n\n\tflags?: Set<string>;\n\tgroups?: Set<string>;\n\toverrides?: Map<string, string>;\n\n\tconstructor(options: IDeckCardOptions) {\n\t\toptions.defer = true;\n\t\tsuper(options);\n\n\t\tthis.quantity = options.quantity;\n\n\t\tif (options.flags) {\n\t\t\tthis.flags = options.flags;\n\t\t}\n\n\t\tif (options.groups) {\n\t\t\tthis.groups = options.groups;\n\t\t}\n\n\t\tif (options.overrides) {\n\t\t\tthis.overrides = options.overrides;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Decklist.writeLine(this);\n\t}\n};\n\nexport { DeckCard };\n","import { DeckCard } from './DeckCard.js';\nimport { Deck } from './Deck.js';\n\nconst Decklist = {\n\twrite(deck: Deck) {\n\t\tlet cards = deck.cards;\n\t\tlet cardsList = cards.map(Decklist.writeLine);\n\n\t\tconst decklist = cardsList.join('\\n');\n\n\t\treturn decklist;\n\t},\n\n\twriteLine(card: DeckCard) {\n\t\tlet line = `${card.quantity}x ${card.name}`;\n\n\t\tif (card.flags) {\n\t\t\tline += Array.from(card.flags).map((flag) => ` *${flag}*`).join('');\n\t\t}\n\n\t\tif (card.groups) {\n\t\t\tline += Array.from(card.groups).map((group) => ` #${group}`).join('');\n\t\t}\n\n\t\tif (card.overrides) {\n\t\t\tline += Array.from(card.overrides).map((override) => ` *${override.join(':')}*`).join('');\n\t\t}\n\n\t\treturn line;\n\t},\n\n\tread(decklist: string) {\n\t\tconst cards = decklist\n\t\t\t.split('\\n')\n\t\t\t.map(Decklist.readLine)\n\t\t\t.filter((value): value is DeckCard => value instanceof DeckCard);\n\n\t\treturn cards;\n\t},\n\n\treadLine(line: string): DeckCard | null {\n\t\tconst flags = Decklist.readLineFlags(line);\n\t\tconst groups = Decklist.readLineGroups(line);\n\t\tconst overrides = Decklist.readLineOverrides(line);\n\n\t\tconst cleanLine = Decklist.cleanLine(line, { flags, groups, overrides });\n\n\t\tconst mainParts = cleanLine.match(/^(\\d+)x (.+)/);\n\n\t\tif (mainParts) {\n\t\t\tconst name = mainParts[2];\n\t\t\tconst quantity = parseInt(mainParts[1], 10);\n\n\t\t\treturn new DeckCard({\n\t\t\t\tname,\n\t\t\t\tquantity,\n\n\t\t\t\tflags,\n\t\t\t\tgroups,\n\t\t\t\toverrides,\n\t\t\t});\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\treadLineFlags(line: string) {\n\t\tconst flagsMatch = line.match(/\\s+\\*[^:]+?\\*/g);\n\t\tif (flagsMatch) {\n\t\t\tconst flags = new Set(flagsMatch.map((flag) => flag.replace(/^\\s+\\*|\\*$/g, '')));\n\t\t\treturn flags;\n\t\t}\n\t},\n\n\treadLineGroups(line: string) {\n\t\tconst groupsMatch = line.match(/\\s+#\\S+/g);\n\t\tif (groupsMatch) {\n\t\t\tconst groups = new Set(groupsMatch.map((group) => group.replace(/^\\s+#/, '')));\n\t\t\treturn groups;\n\t\t}\n\t},\n\n\treadLineOverrides(line: string) {\n\t\tconst overridesMatch = line.match(/\\s+\\*.+?:.+?\\*/g);\n\t\tif (overridesMatch) {\n\t\t\tconst overridesMatrix = overridesMatch.map((override) => override.replace(/^\\s+\\*|\\*$/g, '').split(':'));\n\t\t\tif (overridesMatrix.every((row): row is [string, string] => row.length === 2)) {\n\t\t\t\tconst overrides = new Map(overridesMatrix);\n\t\t\t\treturn overrides;\n\t\t\t}\n\t\t}\n\t},\n\n\tcleanLine(line: string, options?: { groups?: Set<string>, flags?: Set<string>, overrides?: Map<string, string> }) {\n\t\tif (options) {\n\t\t\tif (options.flags) {\n\t\t\t\tconst flagPattern = new RegExp(`\\\\s+\\\\*(${Array.from(options.flags).join('|')})\\\\*`, 'g');\n\t\t\t\tline = line.replace(flagPattern, '');\n\t\t\t}\n\n\t\t\tif (options.groups) {\n\t\t\t\tconst groupPattern = new RegExp(`\\\\s+#(${Array.from(options.groups).join('|')})\\\\b`, 'g');\n\t\t\t\tline = line.replace(groupPattern, '');\n\t\t\t}\n\n\t\t\tif (options.overrides) {\n\t\t\t\tconst overrides = Array.from(options.overrides).map((override) => override.join(':'));\n\t\t\t\tconst overridePattern = new RegExp(`\\\\s+\\\\*(${overrides.map((override) => override.replace(/(\\{|\\})/g, '\\\\$1')).join('|')})\\\\*`, 'g');\n\t\t\t\tline = line.replace(overridePattern, '');\n\t\t\t}\n\t\t}\n\n\t\treturn line;\n\t},\n};\n\nexport { Decklist };\n","import { Card } from './Card.js';\nimport decklist from './data/decklist.js';\nimport { Deck } from './Deck.js';\n\nconst deck = new Deck(decklist);\nconst card = new Card('Forest');\n\n(async () => {\n\tconsole.log(await deck.ready);\n\n\tconsole.log(await card.ready);\n})()\n","import { getCards } from './api/getCard.js';\nimport { DeckCard } from './DeckCard.js';\nimport { Decklist } from './Decklist.js';\n\nclass Deck {\n\tcards: DeckCard[];\n\tready: Promise<this>;\n\n\tconstructor(decklist: string)\n\tconstructor(cards: readonly DeckCard[])\n\tconstructor(cards: string | readonly DeckCard[]) {\n\t\tif (typeof cards === 'string') {\n\t\t\tthis.cards = Decklist.read(cards);\n\t\t} else {\n\t\t\tthis.cards = cards.concat();\n\t\t}\n\n\t\tthis.ready = new Promise((resolve, reject) => {\n\t\t\tPromise.all(this.cards.map((card) => card.ready)).then(() => resolve(this));\n\t\t});\n\n\t\tgetCards(...this.cards.map((card) => card.name)).then((results) => {\n\t\t\tfor (let [i, card] of this.cards.entries()) {\n\t\t\t\tconst data = results[i];\n\t\t\t\tcard.getData(data);\n\t\t\t}\n\t\t});\n\t}\n\n\tget numCards() {\n\t\treturn this.cards.reduce((sum, card) => sum + card.quantity, 0);\n\t}\n\n\ttoString() {\n\t\treturn Decklist.write(this);\n\t}\n}\n\nexport { Deck };\n","export default `1x Abzan Falconer\n1x Arcbond\n1x Atla Palani, Nest Tender *F*\n1x Aura Shards\n1x Beast Whisperer\n1x Bellowing Aegisaur\n1x Boros Charm\n1x Boros Garrison\n1x Boros Guildgate\n1x Boros Signet\n1x Braid of Fire\n1x Brash Taunter\n1x Cacophodon\n1x Colossal Majesty\n1x Command Tower\n1x Congregation at Dawn\n1x Death's Presence\n1x Dense Foliage\n1x Elemental Bond\n1x Enduring Scalelord\n1x Evolving Wilds\n1x Fertilid\n1x Forerunner of the Empire\n5x Forest\n1x Forgotten Ancient\n1x Fury Storm\n1x Gideon's Sacrifice\n1x Gift of Immortality\n1x Gishath, Sun's Avatar\n1x Gleam of Authority\n1x Gruul Guildgate\n1x Gruul Signet\n1x Gruul Turf\n1x Hardened Scales\n1x Hornet Nest\n1x Hungering Hydra\n1x Hydra's Growth\n1x Idol of Oblivion\n1x Illusionist's Bracers\n1x Inspiring Call\n1x Jungle Shrine\n1x Longshot Squad\n1x Marath, Will of the Wild *CMDR*\n1x Marauding Raptor\n1x Mosswort Bridge\n6x Mountain\n1x Needletooth Raptor\n1x Nomads en-Kor\n1x Opal Palace\n1x Oran-Rief, the Vastwood\n1x Overgrowth\n1x Path of Discovery\n1x Pir, Imaginative Rascal\n7x Plains\n1x Polyraptor\n1x Pyrohemia\n1x Ranging Raptors\n1x Raptor Hatchling\n1x Ripjaw Raptor\n1x Rite of Passage\n1x Rugged Highlands\n1x Seedborn Muse\n1x Selesnya Guildgate\n1x Selesnya Sanctuary\n1x Shaman en-Kor\n1x Shinewend\n1x Siegehorn Ceratops\n1x Silverclad Ferocidons\n1x Solidarity of Heroes\n1x Song of Freyalise\n1x Stone Quarry\n1x Summoner's Pact *CMC:4* *COST:{2}{G}{G}*\n1x Sungrass Prairie\n1x Swiftfoot Boots\n1x Terramorphic Expanse\n1x Timber Gorge\n1x Together Forever\n1x Tranquil Expanse\n1x Trapjaw Tyrant\n1x Ulasht, the Hate Seed\n1x Unbreakable Formation\n1x Veil of Summer\n1x Victory Chimes\n1x Wilderness Reclamation\n1x Wind-Scarred Crag`;"],"names":["getCards","cardNames","Promise","async","resolve","reject","url","map","encodeURIComponent","join","response","fetch","ok","json","Array","isArray","every","value","isSearchError","data","testData","object","code","status","details","warnings","element","console","error","Error","statusText","Card","name","ready","constructor","options","this","resolveArg","defer","getData","cardName","getCard","then","cardData","DeckCard","quantity","flags","groups","overrides","super","toString","Decklist","writeLine","write","deck","cards","card","line","from","flag","group","override","read","decklist","split","readLine","filter","readLineFlags","readLineGroups","readLineOverrides","mainParts","cleanLine","match","parseInt","flagsMatch","Set","replace","groupsMatch","overridesMatch","overridesMatrix","row","length","Map","flagPattern","RegExp","groupPattern","overridePattern","concat","all","results","i","entries","numCards","reduce","sum","log"],"sourceRoot":""}