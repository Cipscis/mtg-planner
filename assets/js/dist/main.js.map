{"version":3,"file":"main.js","mappings":"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","sources":["webpack://mtg-planner/./server/src/routes.ts","webpack://mtg-planner/./app/assets/js/src/api/getCard.ts","webpack://mtg-planner/./server/src/middleware/typeguards.ts","webpack://mtg-planner/./app/assets/js/src/DeckCard.ts","webpack://mtg-planner/./app/assets/js/src/Card.ts","webpack://mtg-planner/./app/assets/js/src/Decklist.ts","webpack://mtg-planner/./app/assets/js/src/Deck.ts","webpack://mtg-planner/./app/assets/js/src/templates/deckCard.ts","webpack://mtg-planner/./app/assets/js/src/main.ts","webpack://mtg-planner/./app/assets/js/src/data/decklist.ts","webpack://mtg-planner/./app/assets/js/src/templates/deck.ts"],"sourcesContent":["const root = '/api';\n\nconst routes = {\n\troot,\n\tgetCards: `${root}/cards`,\n} as const;\n\nexport default routes;\n","import * as Scry from 'scryfall-sdk';\nimport { isScryCard } from 'server/middleware/typeguards.js';\n\nimport routes from 'server/routes.js';\n\n/** Get data for one or more cards. */\nfunction getCards(...cardNames: string[]): Promise<Array<Scry.Card | null>> {\n\treturn new Promise(async (resolve, reject) => {\n\t\tconst url = `${routes.getCards}?names=${cardNames.map(encodeURIComponent).join('|')}`;\n\n\t\tconst response = await fetch(url);\n\t\tif (response.ok) {\n\t\t\tconst json: unknown = await response.json();\n\n\t\t\tif (Array.isArray(json) && json.every((value: unknown): value is null | Scry.Card => value === null || isScryCard(value))) {\n\t\t\t\tresolve(json);\n\t\t\t} else {\n\t\t\t\tconsole.error(json);\n\t\t\t\treject(new Error('Response data format unrecognised.'));\n\t\t\t}\n\t\t} else {\n\t\t\treject(new Error(`Response not ok. Status: ${response.status} ${response.statusText}`));\n\t\t}\n\t});\n}\n\n/** Get data for a single card. */\nasync function getCard(cardName: string): Promise<Scry.Card | null> {\n\tconst cards = await getCards(cardName);\n\n\treturn cards[0];\n}\n\nexport {\n\tgetCard,\n\tgetCards,\n};\n","import * as Scry from 'scryfall-sdk';\n\nfunction isScryCard(data: unknown): data is Scry.Card {\n\tconst testData = data as Scry.Card;\n\n\tif (\n\t\ttestData && typeof testData === 'object' &&\n\t\ttestData.object === 'card'\n\t) {\n\t\t// This isn't a true test, but it's a good enough one for this purpose.\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport { isScryCard };\n","import { ICardOptions, Card } from './Card.js';\nimport * as Decklist from './Decklist.js';\n\ninterface IDeckCardOptions extends ICardOptions {\n\tquantity: number;\n\n\t/** Flags such as `'*CMDR*'` */\n\tflags?: Set<string>;\n\t/** Groups such as `'#Ramp'` */\n\tgroups?: Set<string>;\n\t/** Overrides such as `'*CMC:3*'` */\n\toverrides?: Map<string, string>;\n}\n\n/**\n * A Magic: The Gathering card in the context of a deck.\n */\nclass DeckCard extends Card implements IDeckCardOptions {\n\tquantity: number;\n\n\tflags?: Set<string>;\n\tgroups?: Set<string>;\n\toverrides?: Map<string, string>;\n\n\tisLand?: boolean;\n\tcmc?: number;\n\tmanaValue?: number;\n\n\tconstructor(options: IDeckCardOptions) {\n\t\toptions.defer = true;\n\t\tsuper(options);\n\n\t\tthis.quantity = options.quantity;\n\n\t\tif (options.flags) {\n\t\t\tthis.flags = options.flags;\n\t\t}\n\n\t\tif (options.groups) {\n\t\t\tthis.groups = options.groups;\n\t\t}\n\n\t\tif (options.overrides) {\n\t\t\tthis.overrides = options.overrides;\n\t\t}\n\n\t\tthis.ready.then(() => {\n\t\t\tthis.isLand = !!this.data!.type_line.match(/\\bLand\\b/);\n\n\t\t\tif (this.isLand === false) {\n\t\t\t\tconst cmcOverride = this.overrides?.get('CMC');\n\t\t\t\tif (cmcOverride && typeof cmcOverride === 'number') {\n\t\t\t\t\tthis.cmc = cmcOverride;\n\t\t\t\t} else {\n\t\t\t\t\tthis.cmc = this.data!.cmc;\n\t\t\t\t}\n\t\t\t\tthis.manaValue = this.cmc;\n\t\t\t}\n\n\t\t});\n\t}\n\n\ttoString() {\n\t\treturn Decklist.writeLine(this);\n\t}\n};\n\nexport { DeckCard };\n","import { getCard } from './api/getCard.js';\n\ninterface ICardOptions {\n\tname: string;\n\tdata?: Awaited<ReturnType<typeof getCard>>;\n\n\t/**\n\t * If set to `true` when creating a Card, the Card will be created without immediately fetching data for it.\n\t * Useful if creating multiple cards at once.\n\t */\n\tdefer?: boolean;\n}\n\n/**\n * A Magic: The Gathering card in an isolated context.\n */\nclass Card implements ICardOptions {\n\tname: string;\n\tdata?: Awaited<ReturnType<typeof getCard>>;\n\n\t/** A Promise that resolves when a card's `data` exists. It resolves to the Card object. */\n\tready: Promise<this>;\n\n\t/** An internal function that can be called to resolve the card's `ready` Promise. */\n\t#resolve!: (this: this) => void;\n\n\tconstructor(options: string)\n\tconstructor(options: ICardOptions)\n\tconstructor(options: string | ICardOptions) {\n\t\tif (typeof options === 'string') {\n\t\t\toptions = { name: options } as ICardOptions;\n\t\t}\n\n\t\tthis.name = options.name;\n\n\t\tthis.ready = new Promise((resolve, reject) => {\n\t\t\tthis.#resolve = () => {\n\t\t\t\tresolve(this);\n\t\t\t};\n\t\t});\n\n\t\tif (options.defer !== true) {\n\t\t\tthis.getData();\n\t\t}\n\t}\n\n\t/**\n\t * Either store already retrieved card data, or retrieve data via the getCard API end point.\n\t */\n\tasync getData(data?: Awaited<ReturnType<typeof getCard>>) {\n\t\tif (typeof this.data === 'undefined') {\n\t\t\tif (data) {\n\t\t\t\tthis.data = data;\n\t\t\t} else {\n\t\t\t\tthis.data = await getCard(this.name);\n\t\t\t}\n\n\t\t\tthis.#resolve();\n\t\t} else if (data) {\n\t\t\tconsole.warn(`WARNING: \\`Card.getData\\` should not be passed data once a Card has already had data retreived.`);\n\t\t}\n\n\t\treturn this.data as Exclude<typeof this.data, undefined>;\n\t}\n};\n\nexport {\n\tICardOptions,\n\n\tCard,\n};\n","import { DeckCard } from './DeckCard.js';\nimport { Deck } from './Deck.js';\n\n/**\n * Write a `Deck` object to a Tapped Out style decklist string.\n */\nexport function write(deck: Deck): string {\n\tlet cards = deck.cards;\n\tlet cardsList = cards.map(writeLine);\n\n\tconst decklist = cardsList.join('\\n');\n\n\treturn decklist;\n}\n\n/**\n * Write a `DeckCard` object to a single line of a Tapped Out style decklist string.\n */\nexport function writeLine(card: DeckCard): string {\n\tlet line = `${card.quantity}x ${card.name}`;\n\n\tif (card.flags) {\n\t\tline += Array.from(card.flags).map((flag) => ` *${flag}*`).join('');\n\t}\n\n\tif (card.groups) {\n\t\tline += Array.from(card.groups).map((group) => ` #${group}`).join('');\n\t}\n\n\tif (card.overrides) {\n\t\tline += Array.from(card.overrides).map((override) => ` *${override.join(':')}*`).join('');\n\t}\n\n\treturn line;\n}\n\n/**\n * Read a Tapped Out style decklist string into an array of `DeckCard` objects.\n */\nexport function read(decklist: string): DeckCard[] {\n\tconst cards = decklist\n\t\t.split('\\n')\n\t\t.map(readLine)\n\t\t.filter((value): value is DeckCard => value instanceof DeckCard);\n\n\treturn cards;\n}\n\n/**\n * Read a single line of a Tapped Out style decklist string.\n */\nfunction readLine(line: string): DeckCard | null {\n\tconst flags = readLineFlags(line);\n\tconst groups = readLineGroups(line);\n\tconst overrides = readLineOverrides(line);\n\n\tconst cleanedLine = cleanLine(line, { flags, groups, overrides });\n\n\tconst [quantity, name] = readCleanedLineQuantityAndName(cleanedLine);\n\n\tif (quantity && name) {\n\t\treturn new DeckCard({\n\t\t\tname,\n\t\t\tquantity,\n\n\t\t\tflags,\n\t\t\tgroups,\n\t\t\toverrides,\n\t\t});\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/** Read a decklist line's flags, such as `'*CMDR*'` */\nfunction readLineFlags(line: string): DeckCard['flags'] {\n\tconst flagsMatch = line.match(/\\s+\\*[^:]+?\\*/g);\n\tif (flagsMatch) {\n\t\tconst flags = new Set(flagsMatch.map((flag) => flag.replace(/^\\s+\\*|\\*$/g, '')));\n\t\treturn flags;\n\t}\n}\n\n/** Read a decklist line's groups, such as `'#Ramp'` */\nfunction readLineGroups(line: string): DeckCard['groups'] {\n\tconst groupsMatch = line.match(/\\s+#\\S+/g);\n\tif (groupsMatch) {\n\t\tconst groups = new Set(groupsMatch.map((group) => group.replace(/^\\s+#/, '')));\n\t\treturn groups;\n\t}\n}\n\n/** Read a decklist line's overrides, such as `'*CMC:3*'` */\nfunction readLineOverrides(line: string): DeckCard['overrides'] {\n\tconst overridesMatch = line.match(/\\s+\\*.+?:.+?\\*/g);\n\tif (overridesMatch) {\n\t\tconst overridesMatrix = overridesMatch.map((override) => override.replace(/^\\s+\\*|\\*$/g, '').split(':'));\n\t\tif (overridesMatrix.every((row): row is [string, string] => row.length === 2)) {\n\t\t\tconst overrides = new Map(overridesMatrix);\n\t\t\treturn overrides;\n\t\t}\n\t}\n}\n\n/** Remove known flag, group, and override strings from a decklist line so only the quantity and card name remain. */\nfunction cleanLine(line: string, options?: { groups?: Set<string>, flags?: Set<string>, overrides?: Map<string, string> }): string {\n\tif (options) {\n\t\tif (options.flags) {\n\t\t\tconst flagPattern = new RegExp(`\\\\s+\\\\*(${Array.from(options.flags).join('|')})\\\\*`, 'g');\n\t\t\tline = line.replace(flagPattern, '');\n\t\t}\n\n\t\tif (options.groups) {\n\t\t\tconst groupPattern = new RegExp(`\\\\s+#(${Array.from(options.groups).join('|')})\\\\b`, 'g');\n\t\t\tline = line.replace(groupPattern, '');\n\t\t}\n\n\t\tif (options.overrides) {\n\t\t\tconst overrides = Array.from(options.overrides).map((override) => override.join(':'));\n\t\t\tconst overridePattern = new RegExp(`\\\\s+\\\\*(${overrides.map((override) => override.replace(/(\\{|\\})/g, '\\\\$1')).join('|')})\\\\*`, 'g');\n\t\t\tline = line.replace(overridePattern, '');\n\t\t}\n\t}\n\n\treturn line;\n}\n\n/** Read a cleaned decklist line's quantity and card name, such as `'10x Forest'` */\nfunction readCleanedLineQuantityAndName(cleanedLine: string): [DeckCard['quantity'], DeckCard['name']] | [undefined, undefined] {\n\tconst quantityAndNameMatch = cleanedLine.match(/^(\\d+)x (.+)/);\n\n\tif (quantityAndNameMatch) {\n\t\tconst quantity = parseInt(quantityAndNameMatch[1], 10);\n\t\tconst name = quantityAndNameMatch[2];\n\n\t\treturn [quantity, name];\n\t} else {\n\t\treturn [,,];\n\t}\n}\n","import { getCards } from './api/getCard.js';\nimport { DeckCard } from './DeckCard.js';\nimport * as Decklist from './Decklist.js';\n\ninterface IDeckOptions {\n\tname: string;\n\tcards: string | DeckCard[];\n};\n\n/** A Magic: The Gathering deck. */\nclass Deck {\n\tname: string;\n\tcards: DeckCard[];\n\n\t/** A Promise that resolves when a deck's cards' `data` properties are all set. It resolves to the Deck object. */\n\tready: Promise<this>;\n\n\tconstructor(options: IDeckOptions)\n\tconstructor(cards: readonly DeckCard[])\n\tconstructor(decklist: string)\n\tconstructor(options: IDeckOptions | readonly DeckCard[] | string) {\n\t\tif (typeof options === 'string') {\n\t\t\tthis.name = 'New Deck';\n\t\t\tthis.cards = Decklist.read(options);\n\t\t} else if ('length' in options) {\n\t\t\tthis.name = 'New Deck';\n\t\t\tthis.cards = options.concat();\n\t\t} else {\n\t\t\tthis.name = options.name;\n\n\t\t\tif (typeof options.cards === 'string') {\n\t\t\t\tthis.cards = Decklist.read(options.cards);\n\t\t\t} else {\n\t\t\t\tthis.cards = options.cards.concat();\n\t\t\t}\n\t\t}\n\n\t\tthis.ready = new Promise((resolve, reject) => {\n\t\t\tPromise.all(this.cards.map((card) => card.ready)).then(() => resolve(this));\n\t\t});\n\n\t\t// Get data for each card in the deck using `getCards` to reduce requests,\n\t\t// then set it on the cards when the data comes back.\n\t\tgetCards(...this.cards.map((card) => card.name)).then((results) => {\n\t\t\tfor (let [i, card] of this.cards.entries()) {\n\t\t\t\tconst data = results[i];\n\t\t\t\tcard.getData(data);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** The number of cards in the deck. */\n\tget numCards(): number {\n\t\treturn this.cards.reduce((sum, card) => sum + card.quantity, 0);\n\t}\n\n\tget manaCurve(): Map<number, number> {\n\t\tconst curve: Map<number, number> = new Map;\n\n\t\tthis.cards.forEach((card) => {\n\t\t\tconst manaValue = card.manaValue;\n\t\t\tif (typeof manaValue !== 'undefined') {\n\t\t\t\tif (curve.has(manaValue) === false) {\n\t\t\t\t\tcurve.set(manaValue, 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurve.set(manaValue, (curve.get(manaValue) as number) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn curve;\n\t}\n\n\ttoString() {\n\t\treturn Decklist.write(this);\n\t}\n}\n\nexport { Deck };\n","import { DeckCard } from '../DeckCard.js';\n\nexport default (card: DeckCard) => `\n\t<div class=\"deck__card\">${card}</div>\n`;\n","import { Deck } from './Deck.js';\n\nimport deckTemplate from './templates/deck.js';\n\nimport decklist from './data/decklist.js';\n\nconst $deckArea = document.querySelector('.js-deck-area');\nif ($deckArea) {\n\tconst deck = new Deck({\n\t\tname: 'Marath',\n\t\tcards: decklist,\n\t});\n\n\tdeck.ready.then(() => {\n\t\t$deckArea.innerHTML = deckTemplate(deck);\n\t});\n}\n","export default `1x Abzan Falconer\n1x Arcbond\n1x Atla Palani, Nest Tender *F*\n1x Aura Shards\n1x Beast Whisperer\n1x Bellowing Aegisaur\n1x Boros Charm\n1x Boros Garrison\n1x Boros Guildgate\n1x Boros Signet\n1x Braid of Fire\n1x Brash Taunter\n1x Cacophodon\n1x Colossal Majesty\n1x Command Tower\n1x Congregation at Dawn\n1x Death's Presence\n1x Dense Foliage\n1x Elemental Bond\n1x Enduring Scalelord\n1x Evolving Wilds\n1x Fertilid\n1x Forerunner of the Empire\n5x Forest\n1x Forgotten Ancient\n1x Fury Storm\n1x Gideon's Sacrifice\n1x Gift of Immortality\n1x Gishath, Sun's Avatar\n1x Gleam of Authority\n1x Gruul Guildgate\n1x Gruul Signet\n1x Gruul Turf\n1x Hardened Scales\n1x Hornet Nest\n1x Hungering Hydra\n1x Hydra's Growth\n1x Idol of Oblivion\n1x Illusionist's Bracers\n1x Inspiring Call\n1x Jungle Shrine\n1x Longshot Squad\n1x Marath, Will of the Wild *CMDR*\n1x Marauding Raptor\n1x Mosswort Bridge\n6x Mountain\n1x Needletooth Raptor\n1x Nomads en-Kor\n1x Opal Palace\n1x Oran-Rief, the Vastwood\n1x Overgrowth\n1x Path of Discovery\n1x Pir, Imaginative Rascal\n7x Plains\n1x Polyraptor\n1x Pyrohemia\n1x Ranging Raptors\n1x Raptor Hatchling\n1x Ripjaw Raptor\n1x Rite of Passage\n1x Rugged Highlands\n1x Seedborn Muse\n1x Selesnya Guildgate\n1x Selesnya Sanctuary\n1x Shaman en-Kor\n1x Shinewend\n1x Siegehorn Ceratops\n1x Silverclad Ferocidons\n1x Solidarity of Heroes\n1x Song of Freyalise\n1x Stone Quarry\n1x Summoner's Pact *CMC:4* *COST:{2}{G}{G}*\n1x Sungrass Prairie\n1x Swiftfoot Boots\n1x Terramorphic Expanse\n1x Timber Gorge\n1x Together Forever\n1x Tranquil Expanse\n1x Trapjaw Tyrant\n1x Ulasht, the Hate Seed\n1x Unbreakable Formation\n1x Veil of Summer\n1x Victory Chimes\n1x Wilderness Reclamation\n1x Wind-Scarred Crag`;","import { Deck } from '../Deck.js';\nimport deckCardTemplate from './deckCard.js';\n\nexport default (deck: Deck) => `\n\t<section class=\"deck\">\n\t\t<h1 class=\"deck__name\">${deck.name}</h1>\n\n\t\t<dl class=\"deck__mana-curve\">\n\t\t\t${Array.from(deck.manaCurve).sort((a, b) => a[0] - b[0]).map(([value, number]): string => `\n\t\t\t\t<div class=\"deck__mana-curve__item\">\n\t\t\t\t\t<dt class=\"deck__mana-curve__value\">${value}</dt>\n\t\t\t\t\t<dd class=\"deck__mana-curve__number\" style=\"height: ${number}em;\">${number}</dt>\n\t\t\t\t</div>\n\t\t\t`).join('')}\n\t\t</dl>\n\n\t\t<ul class=\"deck__cards\">\n\t\t\t${deck.cards.map((card): string => {\n\t\t\t\treturn deckCardTemplate(card);\n\t\t\t}).join('')}\n\t\t</ul>\n\t</section>\n`;\n"],"names":["getCards","cardNames","Promise","async","resolve","reject","url","map","encodeURIComponent","join","response","fetch","ok","json","Array","isArray","every","value","data","object","console","error","Error","status","statusText","DeckCard","name","ready","constructor","options","this","defer","getData","cardName","getCard","warn","quantity","flags","groups","overrides","isLand","cmc","manaValue","super","then","type_line","match","cmcOverride","get","toString","writeLine","card","line","from","flag","group","override","read","decklist","split","readLine","filter","flagsMatch","Set","replace","readLineFlags","groupsMatch","readLineGroups","overridesMatch","overridesMatrix","row","length","Map","readLineOverrides","cleanedLine","flagPattern","RegExp","groupPattern","overridePattern","cleanLine","quantityAndNameMatch","parseInt","readCleanedLineQuantityAndName","Deck","cards","concat","all","results","i","entries","numCards","reduce","sum","manaCurve","curve","forEach","has","set","$deckArea","document","querySelector","deck","innerHTML","sort","a","b","number","deckCard"],"sourceRoot":""}